
##

查询增加用主从

写入增加分库表

## 主从分离

主从读写分离有两个技术上的关键点：

1. 一个是数据的拷贝，我们称为主从复制；
2. 在主从分离的情况下，我们如何屏蔽主从分离带来的访问数据库方式的变化，让开发同学像是在使用单一数据库一样。

## 在实际使用中，一般一个主库最多挂 3～5 个从库。
因为随着从库数量增加，从库连接上来的 IO 线程比较多，主库也需要创建同样多的 log dump 线程来处理复制的请求，对于主库资源消耗比较高，同时受限于主库的网络带宽
1. 主库的复制线程数增加
2. 受到网路带宽的限制


## 主从复制也有一些缺陷，除了带来了部署上的复杂度，还有就是会带来一定的主从同步的延迟
 如何解决 同步延迟

 第一种方案是数据的冗余

 第二种方案是使用缓

 最后一种方案是查询主库



> 缓存的方案比较适合新增数据的场景，在更新数据的场景下，先更新缓存可能会造成数据的不一致


## 2. 如何访问数据库

为了降低实现的复杂度，业界涌现了很多数据库中间件来解决数据库的访问问题，这些中间件可以分为两类。

早期阿里巴巴开源的 Cobar，基于 Cobar 开发出来的 Mycat


## 分库分表

如何对数据库做垂直拆分
分库分表是一种常见的将数据分片的方式，它的基本思想是依照某一种策略将数据尽量平均的分配到多个数据库节点或者多个表中。

#### 垂直拆分

的原则一般是按照业务类型来拆分，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。举个形象的例子就是在整理衣服的时候，将羽绒服、毛衣、T 恤分别放在不同的格子里。这样可以解决我在开篇提到的第三个问题：把不同的业务的数据分拆到不同的数据库节点上，这样一旦数据库发生故障时只会影响到某一个模块的功能，不会影响到整体功能，从而实现了数据层面的故障隔离。


### 如何对数据库做水平拆分

1 按照某一个字段的哈希值做拆分

2 另一种比较常用的是按照某一个字段的区间来拆分



###  解决分库分表引入的问题

分库分表引入的一个最大的问题就是引入了分库分表键，也叫做分区键

#### 映射表 解决分库分表的问题
所以最合适的思路是你要建立一个昵称和 ID 的映射表，在查询的时候要先通过昵称查询到 ID，再通过 ID 查询完整的数据，这个表也可以是分库分表的，也需要占用一定的存储空间，但是因为表中只有两个字段，所以相比重新做一次拆分还是会节省不少的空间的。

#### 分库分表引入的另外一个问题是一些数据库的特性在实现时可能变得很困难
join count group orderby  聚合 排序 过滤 like 
比方说将计数的数据单独存储在一张表中或者记录在 Redis 里面。

经历过分库分表后的系统，才能够突破单机的容量和请求量的瓶颈


