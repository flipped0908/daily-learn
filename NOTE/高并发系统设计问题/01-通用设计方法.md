
### 大流量
历史上的治水案例
1. 大禹治水 扩宽河道 -> 提升cpu核数和内存
2. 都江堰 引流  ->  分布式扩展
3. 三门峡和葛洲坝采用了使用了水库  ->  缓存
   
### 对抗流量常用的方法

1. 横向扩展 分流  分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。
2. 缓存 使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。
3. 异步：在某些场景下，未处理完成之前，我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。

方法的实现呢

1. 当单机达到极限无法满足我们的流量需求的时候，我们要考虑扩大单机资源的配置还是扩充机器（扩充机器会带来单点和节点一致性性问题也就是常说的分布式问题，那么） 怎么解决分布式问题，业内很好的中间件，zk，kakfa，都是集群，他们的原理可以帮我们给我们提供思路。
2. 缓存什么时候用，cpu和内存的寻址大概在纳秒级别，磁盘的寻址在毫秒级别，千兆网卡读数据的时间在微妙级别。任何可以降低响应时间的中间存储都是缓存，cpu的二级缓存，文件有pagecache缓存
3. 异步 异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。这里边用到了回调，通知的手段。在java中也就是启动另外一个线程去处理其他的事情，如果不需要返回结果用 runable ，需要返回事件可以 用callable，futher。这是不解耦的情况。随着业务的复杂。数据量的增加，单机无法解决要扩展。这时候我们引入了消息队列，产生了生产者和消费者的模式。 


### 高并发系统的演进
高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的。   
项目初期很可能没有考虑到数据量会达到一定的高度。所以就需要后边的人一点点的修改。

系统的演进思路  
1. 最简单的系统设计满足业务需求和流量现状，选择最熟悉的技术体系。
2. 随着流量的增加和业务的变化，修正架构中存在问题的点，如单点问题，横向扩展问题，性能无法满足需求的组件。在这个过程中，选择社区成熟的、团队熟悉的组件帮助我们解决问题，在社区没有合适解决方案的前提下才会自己造轮子。
3. 当对架构的小修小补无法满足需求时，考虑重构、重写等大的调整方式以解决现有的问题。